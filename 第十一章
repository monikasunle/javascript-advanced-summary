函数方法与prototype方法
·实例对象中的方法可以写在构造函数内，也可以写在构造函数prototype属性上
-把方法卸载构造函数内的情况简称为函数内方法
-把方法卸载prototype属性上的情况简称为prototype上的方法
·定义在构造函数内部的方法，会在它的每一个实例上都克隆这个方法（会重新分配内存）
·定义在构造函数的prototype属性上的方法会让它的所有实例对象都共享这个方法，但是不会在每个实例的内部重新定义这个方法（不会重新分配内存）
·如果我们的应用需要创建很多新的对象，并且这些对象还有许多的方法，为了节省内存，建议把这些方法都定义在构造函数的prototype属性上
·在某些情况下，我们需要将某些方法定义在构造函数中，这种情况一般需要访问构造函数内部的私有变量
·函数内方法：定义在构造函数内部的方法，会在它的每一个实例对象上都克隆这个方法，内存占用比较大，但可以访问函数内部的私有变量
·prototype 上的方法：定义在构造函数的 prototype 属性上的方法会让它的所有实例对象都共享这个方法，但是不会在每个实例对象的内部重新定义这个方法，内存占用比较小，但不可以访问函数内部的私有变量
var Person = function(name,sex){
this.name = name;
this.sex = sex;
var _privateVariable = “”;  //私有变量
//构造器中定义的方法，即为私有方法
function privateMethod(){
_privateVariable = “privte value”;
alert(“私有方法被调用！私有成员值：” + _privateVariable);
}
privateMethod();  //构造器内部可以调用私有方法
}
Person.prototype.sayHello = function(){
alert(“姓名：” + this.name + ”，性别：” + this.sex);
};
Var p = new Person(”易烊千玺”,”男”);
p.sayHello();
p.privatemethod();  //这里将报错，私有方法无法被实例对象调用
alert(p._privateVariable);  //显示：undefined
递归
·递归
-一个方法重复调用自身的情况叫做递归
-但是需要注意的是，一定要有一个条件来结束递归，否则会陷入无限的循环
·斐波那契数列
-1,1,2,3,5,8,13,21,34...
深浅拷贝
·拷贝
-浅拷贝
··拷贝基本类型的值
··拷贝引用类型的引用（地址）
----对象拷贝时，如果属性值是引用数据类型时，这时传递的只是一个地址，因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间
··浅拷贝不是直接赋值，而是新建了一个对象，然后将源对象的属性都一一复制过来
-深拷贝（浅拷贝+递归）
··拷贝基本类型的值
··拷贝引用类型时（比如数组和或对象），使用递归，把父对象中所有属于引用类型的对象都遍历赋给子对象即可
·浅拷贝： 将原对象或原数组的引用直接赋给新对象的属性，新对象/数组的属性只是原对象属性的一个引用
·深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”拷贝过来，是“值”而不是“引用”
·深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。
·深拷贝的缺点
-虽然深拷贝能够避免浅拷贝出现的问题，但是却会带来性能上的问题，如果一个对象非常复杂或数据庞大，性能消耗也会增加
·为什么要使用拷贝？
-我们希望在改变新的数组（对象）的时候，不改变原数组（对象）
·拷贝的要求程度
-是仅“深”拷贝第一层级的对象属性或数组元素
-还是递归拷贝所有层级的对象属性和数组元素
·检验拷贝成功
-改变一个新对象/数组中的属性/元素，都不改变原对象/数组
继承
·继承
-继承属性和方法
-继承，本质上讲是一种代码重用机制
·[[prototype]] 与 __proto__
-[[prototype]] 和 __proto__ 意义相同，其值指向对象原型
-[[prototype]] 是内置属性，是一个规范或标准属性，用户不可访问
-__proto__ 不是一个规范或标准属性，但是在部分浏览器实现了此属性
·原型继承
-将子级的原型对象设置为父级的一个实例
-优点：实例是子级的实例，也是父级的一个实例。父级新增原型方法/属性，子级都能访问到
-缺点：所有的实例都会公用一个原型链，如果通过一个实例修改原型属性，那么所有实例访问的值都会被修改
·构造继承
-通过使用 call、apply 方法可以在子级构造函数上执行父级构造函数
-优点：直接继承父级构造函数中的属性和方法
-缺点：构造函数的继承相当于将父级复制给子级，在子级中实现了所有父级的方法，影响子级的性能。另外无法继承原型链上的属性和方法。
·原型链继承能继承父级原型链上的属性，但是可能会存在篡改的问题；而构造函数继承不会存在篡改的问题，但是不能继承原型上面的属性。
·☆组合继承
-构造继承 + 原型继承
-优点：继承父级构造函数和原型上的属性和方法
-缺点：调用了两次父级的构造函数，有些许损耗性能，并且子级的构造函数的属性会和原型上面的属性重合
·原型式继承（类似与原型继承）
-原型式继承并不需要定义一个构造函数，传入参数obj，生成一个继承 obj 对象的对象
-Object.create(obj) —— 静态属性
··创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
·寄生式继承
-寄生式继承是于原型式继承紧密相关的一种思路。既创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后返回对象。
·☆寄生组合式继承（构造继承 + 寄生式继承）
-只调用一次父级构造函数，并且还能继承原型链上面的方法。
