事件绑定
·事件绑定分为两种：一种是传统事件绑定(内联模型，脚本模型)，一种是现代事件绑定(DOM2级模型)
·内联模型
-<button onclick="tell();">弹出提示框</button>
-违反了“内容与行为相分离的原则”，尽量少用
·脚本模型
-document.getElementById('btn').onclick = function(){  }
-实现了“内容与行为相分离”但元素只能绑定一个监听函数
·DOM2 模型
-实现了“内容与行为相分离”
-元素可以绑定多个监听函数
-element.addEventListener(type， listener[， useCapture])
-type —— 表示监听事件类型的字符串，不需要加“on”前缀
-listener —— 指定事件触发时执行的函数
-useCapture —— 布尔值，指定事件是否在捕获或冒泡阶段触发
·EventTarget 对象
-EventTarget 是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。
-Element，document 和 window 是最常见的事件目标，但是其他对象也可以是事件目标，比如 XMLHttpRequest。
-许多事件目标（包括元素，文档和 window）还支持通过 on... 属性设置事件处理程序。
·addEventListener()
-注册特定事件类型的事件处理程序
·removeEventListener(type，listener)
-删除事件侦听器
-具名函数可删除，匿名函数不可删除
·dispatchEvent()
-向一个指定的事件目标派发一个事件
·事件三要素说明
-事件是被动触发的，并不是我们能主动“加”上去的。
-元素只要符合某种事件的触发条件（比如鼠标点击），事件就必定会触发。
-我们所谓的“加”上去的是 JavaScript 对事件的处理函数（没有加的话就不会对事件做任何处理，但并不等于说事件就没有触发）。
·获取DOM元素
- querySelector() 方法
··返回文档中匹配指定 CSS 选择器的一个元素
-querySelectorAll() 方法
··返回文档中匹配指定 CSS 选择器的所有元素
事件流
·事件流
-描述从页面接受事件的顺序
··当几个都具有事件的元素层叠在一起的时候，那么你点击其中一个元素，并不是只有当前被点击的元素会触发事件，而层叠在你点击范围的所有元素都会触发事件
-事件流包括两种模式：冒泡和捕获
··现代浏览器默认情况下都是冒泡模型
··IE 不支持捕获，只支持冒泡
·冒泡
-JavaScript 中的事件冒泡
··事件按照从目标元素到根元素（document对象）的顺序触发。
··即事件发生的顺序为：button — div — body — html — document
-使用 stopPropagation() 方法阻止事件冒泡
··event.stopPropagation();
·冒泡与事件对象
-一般地，事件在传递过程中会有一些信息，这些是事件的组成部分：事件发生的时间+事件发生的地点+ 事件的类型+事件的当前处理者+其他信息。这些信息被封装到 Event 对象中。
·冒泡事件
- event.bubbles
··返回一个布尔值，表明当前事件是否会向 DOM 树上层元素冒泡
-onmouseover   onmouseout —— 支持冒泡
-onmouseenter  onmouseleave —— 不支持冒泡
·冒泡应用 —— 事件委托（event delegation）
-需求 —— 如果想要在大量子元素中单击任何一个都可以运行一段代码，可以将事件监听器设置在其父节点上，并将事件监听器的影响设置为每个子节点，而不是每个子节点单独设置事件监听器。
·捕获设置
-element.addEventListener(type， listener[， useCapture])
··useCapture：布尔值，指定事件是否在捕获或冒泡阶段触发
···true，指定事件在捕获阶段执行
···false，指定事件在冒泡阶段执行，默认
·事件处理周期
-触发一个事件后，在 HTML 元素间进行传播过程
··第一阶段：事件的捕获，事件对象沿 DOM 树向下传播
··第二阶段：目标触发，执行事件监听函数
··第三阶段：事件冒泡，事件沿 DOM 树向上传播
异步
进程是一个工厂，工厂有它的独立资源
—— 系统分配的内存（独立的一块内存）
工厂之间的相互独立
—— 进程之间相互独立
多个工人协作完成任务
—— 多个线程在进程中协作完成任务
工厂内有一个或多个工人 
—— 一个进程由一个或多个线程组成
工人之间共享空间
—— 同一进程下的各个线程之间共享程序的内存空间
·浏览器是多进程的
-Browser 进程
··主进程
··只有1个
-Plugin 进程（第三方插件进程）
-GPU 进程
··最多1个
··用于3D绘制
-Renderer 进程（浏览器渲染进程）——浏览器内核
··GUI 渲染线程
··JS 引擎线程
··事件触发线程
··定时触发器线程
··HTTP 请求线程
·GUI 渲染线程与 JS 引擎线程互斥
·JavaScript引擎线程
-JavaScript引擎线程是单线程
··JavaScript 的主要用途是与用户互动，以及操作DOM。
-单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
·同步/异步任务
-任务可以分成两种，一种是同步任务，另一种是异步任务。
··同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
··异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
·事件轮询
-消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息（任务）。
-事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。
·任务执行流程
1. 首先判断 JS 是同步还是异步，同步就进入主进程，异步就进入 Event table
2. 异步任务在 event table 中注册函数，当满足触发条件后，被推入event queue（callback queue）
3. 同步任务进入主线程后一直执行,直到主线程空闲时，才会去 event queue 中查看是否有可执行的异步任务，如果有就推入主进程中
·定时器
-定时器执行时间
··主程序执行完毕后执行
·DOM渲染
-JavaScript 引擎线程与 GUI 渲染线程是互斥的
-每次取消息列队中的任务之前进行一次渲染
